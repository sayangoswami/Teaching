

## UML to Code Translation Worksheet

**Instructions:** For each problem, you must create the required Java classes. For methods, only write the **signature** (method stub) unless a specific implementation is required (like setting fields in the constructor). Pay close attention to the **visibility** symbols (`+` / `-`) and **relationships** (diamond arrows).

### Basic Structure & Visibility

This pair focuses on correctly translating fields, visibility, and constructors.

#### 1A: Instructor Problem (The Appointment Scheduler)

**Task:** Create the `Appointment` class. Note the use of the `LocalDate` type.


```mermaid
classDiagram
    class Appointment {
        -date : LocalDate
        -description : String
        -durationMinutes : int
        +Appointment(date : LocalDate, description : String, duration : int)
        +getDate() : LocalDate
        +reschedule(newDate : LocalDate) : void
    }
```

Your solution must correctly include:

1. The three **private** field declarations with correct types.
    
2. The **constructor** that accepts and sets all three fields.
    
3. The two **public** method *stubs* - methods with only signature but no (or minimal) implementation.
    


```java
```

---

#### 1B: Student Problem (The Recipe Book Entry)

**Task:** Create the `Recipe` class. Ensure your method signatures correctly handle the return types and parameter types.

```mermaid
classDiagram
    class Recipe {
        -title : String
        -servings : int
        -cookTimeMinutes : int
        +Recipe(title : String, servings : int)
        +getTitle() : String
        +setCookTime(minutes : int) : void
    }
```

Your solution must correctly include:

1. The three **private** field declarations.
    
2. The **constructor** that accepts and sets only the `title` and `servings` fields.
    
3. The two **public** method stubs, including the setter method.
    

```java
```

---

## Aggregation and Cardinality (Weak "Has-A")

This pair focuses on **Aggregation** (the open diamond `o--`), which means the objects exist independently. The **Cardinality** (`*` or `1`) dictates how you store the relationship (a single object or an array/list of objects).

#### 2A: Instructor Problem (The Sports Team)

**Task:** Create both the `Team` and `Player` classes. In the `Team` class, you must account for the relationship in your field declaration.


```mermaid
classDiagram
    class Team {
        -name : String
        +Team(name : String)
        +addPlayer(p : Player) : void
        +getTeamSize() : int
    }
    class Player {
        -jerseyNumber : int
        -name : String
        +Player(name : String, number : int)
    }
    Team "1" o-- "*" Player : has
```


1. Create the `Player.java` class (all fields and the constructor).
    
2. Create the `Team.java` class. Since the `Team` **"has many"** (`*`) `Player`s, you must declare a private field in `Team` that is an **array of `Player` objects**.
    
    - _Hint:_ `private Player[] roster;`
        
3. Write the method stubs for `addPlayer` and `getTeamSize`.
    


```java
```

---

#### 2B: Student Problem (The Organizational Structure)

**Task:** Create both the `Department` and `Employee` classes, implementing the one-to-many aggregation relationship.


```mermaid
classDiagram
    class Department {
        -name : String
        +Department(name : String)
        +addEmployee(e : Employee) : void
        +printEmployees() : void
    }
    class Employee {
        -id : int
        -salary : double
        +Employee(id : int, salary : double)
    }
    Department "1" o-- "*" Employee : employs
```



1. Create the `Employee.java` class.
    
2. Create the `Department.java` class. Declare a private field in `Department` to hold the **many** (`*`) `Employee` objects.
    
3. Write the method stubs for `addEmployee` and `printEmployees`.
    

```java
```

---

## Composition and Cardinality (Strong "Part-Of")

This pair focuses on **Composition** (the filled diamond `*--`), where the "part" (Chapter/Engine) is owned by and cannot exist without the "whole" (Book/Car).

#### 3A: Instructor Problem (The Vehicle System)

**Task:** Create both the `Car` and `Engine` classes. The composition relationship requires the `Car` class to be responsible for creating the `Engine` object internally.


```mermaid
classDiagram
    class Car {
        -make : String
        +Car(make : String, engineHP : int)
        +start() : void
    }
    class Engine {
        -horsepower : int
        +Engine(hp : int)
        +getHP() : int
    }
    Car "1" *-- "1" Engine : has
```


1. Create the `Engine.java` class (all fields and methods).
    
2. Create the `Car.java` class. Note the `Car` constructor takes `engineHP`, but it does **not** take an `Engine` object.
    
3. Implement the `Car` constructor by **instantiating the `Engine` object inside the `Car` constructor**.
    


```java
```

---

#### 3B: Student Problem (The Book Structure)

**Task:** Create both the `Book` and `Chapter` classes, implementing the one-to-many composition relationship. The `1..*` cardinality means there must be at least one chapter.


```mermaid
classDiagram
    class Book {
        -title : String
        +Book(title : String)
        +addChapter(c : Chapter) : void
    }
    class Chapter {
        -chapterNumber : int
        -pageCount : int
        +Chapter(number : int, pages : int)
    }
    Book "1" *-- "1..*" Chapter : contains
```



1. Create the `Chapter.java` class.
    
2. Create the `Book.java` class. Declare a private field in `Book` that can hold **one or more** (`1..*`) `Chapter` objects (e.g., an array or list).
    
3. Write the method stubs for `addChapter`.


```java
```