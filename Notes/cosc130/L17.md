# Slide 1: Title Slide

**CS2 Programming**

## An Introduction to Recursion

### Thinking in Circles (That Actually End)

# Slide 2: A Motivating Example (Non-Code)

Imagine you have a set of **Russian Nesting Dolls**.

You want to find the _smallest_ doll. What's your algorithm?

1. Open the (current) doll.
    
2. Look inside:
    
    - **Case A:** If there is _another doll_ inside, your problem is now simpler. **Repeat the exact same process (Step 1)** on this new, smaller doll.
        
    - **Case B:** If it's empty (no more dolls), you've found it! You're **done**.
        

This is recursion: **Solving a problem by using the solution to a** _**smaller version of the exact same problem**_**.**

# Slide 3: What is Recursion?

In programming, recursion is a technique where a **function calls itself**.

```
// A (very simple) recursive function
void myMethod() {
    // ... some code ...
    myMethod(); // The function calls itself!
    // ... some code ...
}
```

This looks like an infinite loop, and it will be... unless we add two key parts.

# Slide 4: The Two Parts of Any Recursive Function

Every _correct_ recursive function must have two parts:

### 1. The Base Case

- A simple, non-recursive condition that **stops** the recursion.
    
- This is the "smallest doll" or the "empty" doll.
    
- **What it does:** It provides a direct, simple answer for the _easiest_ version of the problem.
    

### 2. The Recursive Step

- The part where the function calls itself, but with a **simpler or smaller** input.
    
- This is the "open the doll, get the inner one" step.
    
- **What it does:** It moves the problem _one step closer_ to the base case.
    

# Slide 5: Example 1: `countdown(int n)`

Let's write a function that counts down from `n` to 0 and prints "Blastoff!".

```
public void countdown(int n) {
    
    // 1. Base Case:
    if (n == 0) {
        System.out.println("Blastoff!");
    } 
    
    // 2. Recursive Step:
    else {
        System.out.println(n);
        countdown(n - 1); // Solves a *simpler* problem (n-1)
    }
}
```

# Slide 6: How Does This Work? The "Call Stack"

When a function is called, Java uses a **Call Stack** to keep track of it. Think of it as a stack of plates.

- When a new function is called, its "frame" (with its own local variables) is **pushed** onto the top of the stack.
    
- When a function returns, its frame is **popped** off the stack.
    
- Java always executes the function at the **very top** of the stack.
    

# Slide 7: Tracing `countdown(3)`

Let's trace `countdown(3)` and watch the stack.

`main()` calls `countdown(3)` `n=3`. Not base case. Prints "3". Calls `countdown(2)`.

`n=2`. Not base case. Prints "2". Calls `countdown(1)`.

`n=1`. Not base case. Prints "1". Calls `countdown(0)`.

`n=0`. **Base Case!** Prints "Blastoff!". Returns. (Pops off stack)

(Resumes `countdown(1)`) Nothing left to do. Returns. (Pops)

(Resumes `countdown(2)`) Nothing left to do. Returns. (Pops)

(Resumes `countdown(3)`) Nothing left to do. Returns. (Pops)

# Slide 8: The Most Important Error: `StackOverflowError`

What happens if we forget the base case?

```
public void countdown(int n) {
    // NO BASE CASE!
    System.out.println(n);
    countdown(n - 1); 
}
```

Let's trace `countdown(3)`:

- `countdown(3)` calls `countdown(2)`
    
- `countdown(2)` calls `countdown(1)`
    
- `countdown(1)` calls `countdown(0)`
    
- `countdown(0)` calls `countdown(-1)`
    
- `countdown(-1)` calls `countdown(-2)`
    
- ...it never stops!
    

The Call Stack gets deeper and deeper until... **CRASH!** `Exception in thread "main" java.lang.StackOverflowError`

If you see this, you almost certainly forgot your base case or are not making the problem simpler!

# Slide 9: Example 2: Factorial `(n!)`

Let's look at a function that _returns_ a value.

**Mathematical Definition:** `n! = n * (n-1) * (n-2) * ... * 1` `5! = 5 * 4 * 3 * 2 * 1 = 120`

**Recursive Definition:**

- `n! = n * (n-1)!` <-- Recursive Step
    
- `1! = 1` <-- Base Case
    

This mathematical definition is _already recursive_! This makes it easy to code.

# Slide 10: Factorial Code

```
public int factorial(int n) {
    
    // 1. Base Case:
    if (n == 1) {
        return 1;
    } 
    
    // 2. Recursive Step:
    else {
        // n * (solution to simpler problem)
        return n * factorial(n - 1);
    }
}
```

# Slide 11: Tracing `factorial(3)` (The Climb)

`main()` calls `factorial(3)`

- `n=3`. Not base case.
    
- Must return `3 * factorial(2)`.
    
- **PAUSES** and calls `factorial(2)` to get the answer...
    

`factorial(2)`

- `n=2`. Not base case.
    
- Must return `2 * factorial(1)`.
    
- **PAUSES** and calls `factorial(1)`...
    

`factorial(1)`

- `n=1`. **Base Case!**
    
- Returns `1`.
    
- (Pops off stack)
    

# Slide 12: Tracing `factorial(3)` (The Return)

Now the values "unwind" back up the stack.

`factorial(2)` (Resumes)

- It was paused at `return 2 * factorial(1);`
    
- It just got the `1` back from the call.
    
- Returns `2 * 1` (which is `2`).
    
- (Pops off stack)
    

`factorial(3)` (Resumes)

- It was paused at `return 3 * factorial(2);`
    
- It just got the `2` back from the call.
    
- Returns `3 * 2` (which is `6`).
    
- (Pops off stack)
    

`main()`

- Receives the final value of `6`.
    

# Slide 13: Recursion vs. Iteration (Loops)

Any problem you can solve recursively, you can also solve with a loop (iteratively).

| `factorial(n)` - **Recursive**                                                                                              | `factorial(n)` - **Iterative (Loop)**                                                                                  |
| --------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| <br>```<br>public int factorial(int n) { <br>   if (n == 1) return 1;<br>   else return n * factorial(n-1); <br>   }<br>``` | `public int factorial(int n) { int result = 1; for (int i = 1; i <= n; i++) { result = result * i; } return result; }` |
| **Pros:** Often simpler, more elegant code. Matches mathematical definitions.                                               | **Pros:** Usually faster (no function call overhead). Uses less memory (no stack frames).                              |
| **Cons:** Slower, uses more memory. Can be harder to trace.                                                                 | **Cons:** Can be more complex to write and read for some problems (e.g., tree traversal).                              |
|                                                                                                                             |                                                                                                                        |

# Slide 14: Example 3: `reverseString(String s)`

Let's reverse a string. `reverse("cat")` should return `"tac"`

How do we make this simpler?

- **Problem:** `reverse("cat")`
    
- **Simpler Problem:** `reverse("at")` (which gives `"ta"`)
    
- **How to combine?** `reverse("cat") = reverse("at") + 'c'`
    

**Let's formalize this:**

- **Base Case:** If `s` is empty or 1 char, return `s`.
    
- **Recursive Step:** `reverse(s)` = `reverse(s.substring(1))` + `s.charAt(0)`
    

# Slide 15: `reverseString(String s)` Code

```
public String reverseString(String s) {
    
    // 1. Base Case:
    if (s.length() <= 1) {
        return s;
    }
    
    // 2. Recursive Step:
    else {
        String simplerProblem = s.substring(1);
        String solutionToSimpler = reverseString(simplerProblem);
        
        return solutionToSimpler + s.charAt(0);
    }
}
```


# Slide 16: Tracing `reverseString("cat")`

`reverse("cat")`

- Calls `reverse("at")`.
    
- **PAUSES**, waits for result...
    

`reverse("at")`

- Calls `reverse("t")`.
    
- **PAUSES**, waits for result...
    

`reverse("t")`

- **Base Case!** `s.length()` is 1.
    
- Returns `"t"`.
    

`reverse("at")` (Resumes)

- `solutionToSimpler` is `"t"`.
    
- `s.charAt(0)` is `'a'`.
    
- Returns `"t" + 'a'` (which is `"ta"`).
    

`reverse("cat")` (Resumes)

- `solutionToSimpler` is `"ta"`.
    
- `s.charAt(0)` is `'c'`.
    
- Returns `"ta" + 'c'` (which is `"tac"`).
    

**Final Answer:** `"tac"`

---

# Slide 17: How to "Think Recursively"

Don't try to trace the _whole stack_ in your head! You'll get lost.

Instead, just follow these three steps:

1. **Find the Base Case:** What is the _absolute simplest_ version of this problem I can solve directly? (e.t., `n=1`, `n=0`, empty string).
    
2. **Find the Recursive Step:**
    
    - How can I make the problem **one step simpler**? (e.g., `n-1`, `s.substring(1)`).
        
    - **Trust the "Leap of Faith"**: _Assume_ your function works perfectly for that simpler problem.
        
3. **Combine:** How do I use the result from the simpler problem to solve my _current_ problem? (e.g., `n * simplerResult`, `simplerResult + char`).
    

---

# Slide 18: Programming Worksheet: Your Turn!

**1. `sum(n)`**

- Write a recursive function `public int sum(int n)` that returns the sum of all integers from 1 up to `n`. (e.g., `sum(3)` = 1 + 2 + 3 = 6).
    
- **Base Case:** `sum(1)` is 1.
    
- **Recursive Step:** `sum(n) = n + sum(n-1)`
    

**2. `isPalindrome(String s)`**

- A palindrome reads the same forwards and backwards ("racecar", "madam").
    
- Write a recursive function `public boolean isPalindrome(String s)`.
    
- **Hint:** Compare the first and last characters.
    
- **Base Case 1:** If length is 0 or 1, `return true`.
    
- **Base Case 2:** If first char `!=` last char, `return false`.
    
- **Recursive Step:** `return isPalindrome(s.substring(1, s.length() - 1))`
    

**3. (Advanced) `fibonacci(n)`**

- The Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, ...
    
- `fib(0) = 0`, `fib(1) = 1`.
    
- `fib(n) = fib(n-1) + fib(n-2)`.
    
- Write `public int fib(int n)`.