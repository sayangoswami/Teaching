


# Maps and Sets

## Three Core Collection Structures

In Java, we use different **Collection** types based on how we need to organize and access our data. The three fundamental structures are:

1. **List:** The most basic, characterized by order.
    
2. **Set:** Characterized by uniqueness.
    
3. **Map:** Characterized by key-value pairing.
    

These three concepts define how data is stored, retrieved, and whether duplicates are allowed.

## The `List` Structure (`ArrayList`)

The `List` is the most common collection, which you've used extensively.

|Property|Description|
|---|---|
|**Order**|**Ordered** (sequence matters). Items maintain their position (index) based on when they were added.|
|**Duplicates**|**Allowed**. You can store the same element multiple times.|
|**Access**|Accessed by a numerical **index** (position). Use `list.get(2)`.|
|**Implementation**|`ArrayList<E>` is the common concrete class.|

```
import java.util.List;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        //
    }
}
List<String> names = new ArrayList<>();
names.add("Mike");
names.add("Anna");
names.add("Mike"); // Duplicate allowed
System.out.println(names.get(1)); // Output: Anna
```

## The `Set` Structure (`HashSet`)

The `Set` is defined by the rule of uniqueness.

|Property|Description|
|---|---|
|**Order**|**Unordered** (sequence does not matter). The system decides where the item is stored.|
|**Duplicates**|**NOT Allowed**. Adding an existing element is ignored.|
|**Access**|Accessed by **existence** check. Use `set.contains(item)`.|
|**Implementation**|`HashSet<E>` is the common concrete class.|

**Common Use Cases:**

1. **De-duplication:** Quickly removing duplicates from a `List`.
    
2. **Fast Membership Checking:** Checking if a user is an admin, or if a word is in a "banned words" list.
    

## How to use `Set` - Key Methods

`Set` methods are simple and fast.

```
import java.util.Set;
import java.util.HashSet;

public class Main {
    public static void main(String[] args) {
        //
    }
}

Set<String> uniqueIds = new HashSet<>();

// .add(item) - Returns true if added, false if it was already there
boolean added_s101 = uniqueIds.add("s101"); // true
uniqueIds.add("s102");
boolean added_s101_again = uniqueIds.add("s101"); // false

// .size() - Returns the number of unique items
System.out.println(uniqueIds.size()); // 2

// .contains(item) - The "superpower" of a Set. Very fast.
if (uniqueIds.contains("s102")) {
    System.out.println("s102 is in the set.");
}

// .remove(item) - Returns true if the item was found and removed
boolean removed = uniqueIds.remove("s999"); // false
```

## `Set` - Looping & Set Operations

Since there are no indexes (`.get(i)`), we **must** use a "for-each" loop.

```
// Note: The order is not guaranteed!
for (String id : uniqueIds) {
    System.out.println(id);
}
```

**Set Operations (Advanced Use Case):** `Set`s are great for mathematical operations.

```
public class Main {
    public static void main(String[] args) {
        //
    }
}

Set<String> classA = new HashSet<>();
classA.add("Alice");
classA.add("Bob");
classA.add("Charlie");

Set<String> classB = new HashSet<>();
classB.add("Charlie");
classB.add("David");

// Union: Add all items from classB into classA
// classA.addAll(classB);
// System.out.println(classA); // [Alice, Bob, Charlie, David]

// Intersection: Keep only the items that are in BOTH sets
classA.retainAll(classB);
System.out.println(classA); // [Charlie]
```

## The `Map` Structure (`HashMap`)

The `Map` stores associations between two pieces of data.

|Property|Description|
|---|---|
|**Key-Value**|Stores data as pairs: a **Key** and a **Value**.|
|**Order**|**Unordered** by default.|
|**Keys**|Must be **unique**. Keys behave like a `Set`.|
|**Access**|Accessed by the unique **Key**. Use `map.get(key)`.|
|**Generics**|Requires two types: `Map<K, V>` (Key, Value).|
|**Implementation**|`HashMap<K, V>` is the common concrete class.|

**Common Use Cases:**

1. **Direct Lookup:** Student ID -> Student Object, User Name -> Password.
    
2. **Storing Associations:** Configuration Settings ("theme" -> "dark").
    
3. **Counting/Frequency:** Word -> Count.
    

## How to use `Map` - Key Methods (Part 1)

`Map` methods are all about managing keys and values.

```
import java.util.Map;
import java.util.HashMap;

public class Main {
    public static void main(String[] args) {
        //
    }
}

// Key is String (name), Value is Integer (score)
Map<String, Integer> scores = new HashMap<>();

// .put(K, V) - Adds or updates a key-value pair
scores.put("Joe", 88);
scores.put("Kim", 95);
scores.put("Joe", 92); // Updates Joe's score

// .get(K) - The "superpower" of a Map. Very fast.
int kimsScore = scores.get("Kim"); // 95

// .get(K) returns null if the key doesn't exist
Integer samsScore = scores.get("Sam"); // null

// .size()
System.out.println(scores.size()); // 2

// .remove(K) - Removes the key and its value
scores.remove("Kim"); 
```

## How to use `Map` - Key Methods (Part 2)

These methods help you avoid `null` and work with the whole collection.

```
// .containsKey(K) - A fast check to avoid nulls
if (scores.containsKey("Joe")) {
    System.out.println("Joe's score is: " + scores.get("Joe"));
}

// .getOrDefault(K, V) - A very useful shortcut!
// Get "David"'s score. If he's not in the map, return 70.
int davidsScore = scores.getOrDefault("David", 70); // 70

// .isEmpty() and .clear()
boolean isEmpty = scores.isEmpty(); // false
scores.clear(); // Empties the map
```

## `Map` - How to Loop

You can't loop over a `Map` directly. Instead, you loop over its **Set of Keys** or its **Collection of Values**.

```
Map<String, Integer> scores = ... ; // {Joe=92, Kim=95}

// 1. Loop over KEYS (Most common)
Set<String> names = scores.keySet();
for (String name : names) {
    int score = scores.get(name);
    System.out.println(name + ": " + score);
}
// Output: Joe: 92, Kim: 95

// 2. Loop over VALUES (If you only care about the values)
Collection<Integer> allScores = scores.values();
double sum = 0;
for (int score : allScores) {
    sum += score;
}
System.out.println("Average: " + (sum / allScores.size()));
```

## Summary Table: The Differences

Choosing the right structure depends on whether you need order, if you can tolerate duplicates, and how you want to retrieve the data.

|Feature|`List` (`ArrayList`)|`Set` (`HashSet`)|`Map` (`HashMap`)|
|---|---|---|---|
|**Data Structure**|Single items|Unique single items|Key-Value pairs|
|**Order**|**Ordered** (by index)|**Unordered**|**Unordered**|
|**Duplicates**|**Allowed**|**NOT Allowed**|Keys are unique; Values can be duplicates|
|**Retrieval**|By **Index** (`get(i)`)|By **Existence** (`contains(item)`)|By **Key** (`get(key)`)|
|**Generics**|`List<E>`|`Set<E>`|`Map<K, V>`|
