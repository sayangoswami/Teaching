---
customTheme: custom1
highlightTheme: atom-one-light
---


# Abstract Classes

---

## The Problem: Teamwork and Inconsistency

Imagine you're leading a team building a new feature: Reports.

You tell two programmers, Alice and Bob, to create classes for different reports.

- Alice creates `SummaryReport` with a method `generateSummary()`.
    
- Bob creates `DetailReport` with a method `createFullReport()`.
    

**Problem:** The code that _uses_ these classes now has to know about each specific method name. This is messy and leads to bugs! How do we force everyone to follow the same rules?

---

## The Solution: A Contract

We need a way to enforce a **contract** or a **blueprint**.

This contract would say:

> "I don't care _how_ you do it, but any class that is a 'Report' **MUST** provide a method called `generate()`. If you don't, your code won't even be allowed to run."

This is the core idea behind **Abstract Classes**.

---

## What is an Abstract Class?

An abstract class is a special kind of class that serves as a **template** for other classes.

- You **cannot** create an object directly from an abstract class. (`new Report()` would be an error).
    
- It exists only to be **extended** by other classes (subclasses).
    
- It can contain both **regular methods** (with code) and **abstract methods** (the contract).
    

It's a blueprint, not a finished building.

---

## The `abstract` Keyword

We use the `abstract` keyword to create the contract.

**1. The Abstract Class:** The `class` itself is marked as `abstract`.

```java
public abstract class Report {
    // ...
}
```

**2. The Abstract Method:** The method that forms the "rule" is also marked `abstract` and has **no body** (no `{}`).

```java
public abstract String generate(Table studentTable); // Notice the semicolon!
```

---

## Our Report Contract in Code

Here is the blueprint for all `Report` objects in our system.

```java
public abstract class Report {
    private String reportName;

    // A regular constructor, shared by all subclasses
    public Report(String name) {
        this.reportName = name;
    }

    // A regular method, shared by all subclasses
    public String getName() {
        return this.reportName;
    }

    // THE CONTRACT:
    // Any class that extends Report MUST implement this method.
    public abstract String generate(Table studentTable);
}
```

---

## Fulfilling the Contract: Concrete Classes

A "concrete" class is a regular class that `extends` an abstract class and provides the code for all the abstract methods. It "fulfills the contract."

```java
// SummaryReport FULFILLS the Report contract
public class SummaryReport extends Report {

    public SummaryReport() {
        super("Summary Report"); // Calls the parent constructor
    }

    // We provide the required generate() method
    @Override
    public String generate(Table studentTable) {
        // ... specific logic for this report ...
        return "This is a summary.";
    }
}
```

If you forget to implement the `generate` method, Java will give you a compiler error!

---

## Why Not Just a Regular Class?

Why make `Report` abstract at all?

By making it `abstract`, we prevent programmers from making a generic, useless `Report` object.

```java
// This is now impossible, which is GOOD!
// A "Report" with no 'generate' logic is meaningless.
Report myReport = new Report("Some Report"); // ERROR!
```

This forces developers to be specific and create a _useful_ subclass, like `SummaryReport` or `DetailReport`, that actually does something.

---

## Summary

- **Abstract classes are blueprints** for a family of related classes.
    
- They enforce a **contract** that subclasses must follow.
    
- An **abstract method** has no body and must be implemented by subclasses.
    
- You **cannot create an object** from an abstract class.
    
- They are the perfect tool for ensuring consistency and structure in your programs.
    

---

## Programming Worksheet

**Abstract Classes: Hands-On Practice**

Let's apply these concepts to new problems.

---

## Worksheet Problem 1: Geometric Shapes

**Goal:** Create a system for calculating the area of different geometric shapes.

1. **The Contract:** Create an `abstract class` named `Shape`.
    
    - It must have an abstract method: `public abstract double getArea();`
        
    - It must also have another abstract method: `public abstract String getName();`

--
		
2. **The Concrete Classes:** Create two classes, `Circle` and `Rectangle`, that `extend Shape`.
    
    - The `Circle` class needs a constructor `public Circle(double radius)`. It must implement `getArea()` (the formula is `Math.PI * radius * radius`) and `getName()` (should return the string "Circle").
        
    - The `Rectangle` class needs a constructor `public Rectangle(double width, double height)`. It must implement `getArea()` (width * height) and `getName()` (should return "Rectangle").


3. **Putting it all Together:** In your `main` method, create an array of `Shape`s. Add a `new Circle(...)` and a `new Rectangle(...)` to it. Loop through the array and print out the name and area of each shape.
    

---

## Worksheet Problem 2: Employee Payroll

**Goal:** Model different types of employees for a payroll system.

1. **The Contract:** Create an `abstract class` named `Employee`.
    
    - It should have a `String name` and a constructor to initialize it.
        
    - It must have an abstract method: `public abstract double calculateMonthlyPay();`
--

1. **The Concrete Classes:** Create `SalariedEmployee` and `HourlyEmployee` classes that `extend Employee`.
    
    - `SalariedEmployee`'s constructor should take a `name` and an `annualSalary`. Its `calculateMonthlyPay()` method must return the annual salary divided by 12.
        
    - `HourlyEmployee`'s constructor should take a `name`, an `hourlyRate`, and `hoursWorkedThisMonth`. Its `calculateMonthlyPay()` must return the rate multiplied by the hours worked.
        
2. **Putting it all Together:** In your `main` method, create an array of `Employee`s containing one salaried and one hourly employee. Loop through the array and print a payroll summary for each, like: `"Jane Doe (Salaried) pay is $5000.00"`.