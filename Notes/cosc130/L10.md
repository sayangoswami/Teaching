---
customTheme: custom1
highlightTheme: atom-one-light
---
# Polymorphism


---

## What is Polymorphism?

**Definition:**

- From Greek: "poly" (many) and "morph" (forms).
    
- In Java, polymorphism allows objects of different classes to be treated as objects of a common superclass.
    
- It's a core concept of Object-Oriented Programming (OOP) that enables flexibility and extensibility.
    

**Key Idea:**

- A single interface can represent different underlying forms/types.
    

---

## Two Main Types of Polymorphism

**Compile-Time Polymorphism (Method Overloading)**

- **Definition:** Multiple methods in the same class have the same name but different parameter lists (different number, type, or order of arguments).
    
- **Resolution:** Decided at compile time based on the method signature.
    
- **Example:**
    
    ```java
    class Calculator {
        int add(int a, int b) { return a + b; }
        double add(double a, double b) { return a + b; }
        int add(int a, int b, int c) { return a + b + c; }
    }
    ```
    

---

## Two Main Types of Polymorphism

**Runtime Polymorphism (Method Overriding)**

- **Definition:** A subclass provides a specific implementation for a method that is already defined in its superclass.
    
- **Requirements:**
    - Methods must have the exact same signature (name, parameters).
    - Methods must have compatible return types.
    - Access modifier in the subclass cannot be more restrictive.
    - Only applies to inherited instance methods.
        
- **Resolution:** Decided at runtime based on the actual object type, not the reference type.
    
- **Annotation:** Use `@Override` for clarity and compile-time checks.
    

---

## Runtime Polymorphism Example

Consider a `Shape` superclass and `Circle`, `Rectangle` subclasses.

```java
class Shape {
    void draw() {
        System.out.println("Drawing a generic shape");
    }
}

class Circle extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a Circle");
    }
}

class Rectangle extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a Rectangle");
    }
}
```

Now, let's see it in action...

---

## Runtime Polymorphism - The Magic



```java
public class DemoShapes {
    public static void main(String[] args) {
        Shape s1 = new Circle();     // Shape reference, Circle object
        Shape s2 = new Rectangle();  // Shape reference, Rectangle object
        Shape s3 = new Shape();      // Shape reference, Shape object

        s1.draw(); // Calls Circle's draw()
        s2.draw(); // Calls Rectangle's draw()
        s3.draw(); // Calls Shape's draw()
    }
}
```

--

**Output:**

```txt
Drawing a Circle
Drawing a Rectangle
Drawing a generic shape
```

**Explanation:** Even though `s1`, `s2`, and `s3` are all declared as `Shape` references, the correct `draw()` method is called based on the _actual object type_ they refer to at runtime.


---


### Why Runtime Polymorphism is a Game-Changer

On the surface, polymorphism can look like an overly academic concept. But in reality, it is one of the most powerful tools we have for writing clean, flexible, and maintainable software. It solves a very common and painful problem.

Let's explore this by first looking at a world _without_ polymorphism and then seeing how it saves us.

--

#### The Problem: The Rigid `if-else` Chain

Imagine you're building a video game. You have different types of characters, and each one attacks differently.

```java
// Our character classes
class Mage {
    public void castFireball() { 
	    System.out.println("Mage casts a fireball!"); 
	}
}

class Warrior {
    public void swingSword() { 
	    System.out.println("Warrior swings a mighty sword!"); 
	}
}

class Archer {
    public void shootArrow() { 
	    System.out.println("Archer shoots a flaming arrow!"); 
	}
}
```

--

Now, let's say we have a list of all the characters currently in a battle, and we want to make them all perform their attack.

Without polymorphism, your code might look like this:

```java
// An array holding different types of objects
Object[] characters = { 
	new Mage(), new Warrior(), new Archer(), new Warrior() 
};

// The main game loop that processes attacks
for (Object character : characters) {
    if (character instanceof Mage) {
        Mage mage = (Mage) character; // We have to cast it to the right type
        mage.castFireball();
    } else if (character instanceof Warrior) {
        Warrior warrior = (Warrior) character;
        warrior.swingSword();
    } else if (character instanceof Archer) {
        Archer archer = (Archer) character;
        archer.shootArrow();
    }
}
```

--

**What's wrong with this code?**

1) **It's Brittle and Hard to Maintain:** What happens when we add a new character, like a `Thief`? We have to go back to this exact spot in the code (and any other place like it) and add another `else if` block. Forgetting one will create a bug. This is a maintenance nightmare.
2) **It Violates the Open/Closed Principle:** A core principle of good design is that your code should be **open for extension** (you can add new character types) but **closed for modification** (you shouldn't have to change existing, working code like the game loop). This code fails that test completely.
3) **The Code is Not Scalable:** Imagine 50 character types. This `if-else` block would be enormous, slow, and impossible to read.
4) This approach forces the _game loop_ to know about every single type of character. The logic is centralized and rigid.

---

### The Solution: Polymorphism and Dynamic Dispatch

Now, let's redesign this using inheritance and polymorphism. We'll create a common "contract" or superclass.

**Step 1: Create a Common Superclass**

We'll create a `Character` class with a single method, `attack()`.

```java
class Character {
    // All characters MUST provide a way to attack.
    public abstract void attack() {
	    // some generic attck method
    }
}
```

--

**Step 2: Subclasses Implement the `attack()` Method**

Each character class now `extends` `Character` and provides its own specific version of `attack()`.

```java
class Mage extends Character {
    @Override
    public void attack() {
        System.out.println("Mage casts a fireball!");
    }
}

class Warrior extends Character {
    @Override
    public void attack() {
        System.out.println("Warrior swings a mighty sword!");
    }
}

class Archer extends Character {
    @Override
    public void attack() {
        System.out.println("Archer shoots a flaming arrow!");
    }
}
```

--

**Step 3: The Beautifully Simple Main Loop**

Now, look at how clean our main loop becomes. We create an array of `Character` references.

```java
// An array of Character references, pointing to different concrete objects
Character[] characters = { new Mage(), new Warrior(), new Archer(), new Warrior() };

// The beautifully simple and flexible main loop
for (Character character : characters) {
    // The magic happens here!
    character.attack();
}
```

--

### Dynamic Dispatch

When the line `character.attack()` is executed, the Java Virtual Machine (JVM) does something amazing:

1. It looks at the `character` variable.
    
2. It checks the **actual type of the object** that the variable is pointing to _at that moment in runtime_.
    
3. Is it pointing to a `Mage`? The JVM **dynamically dispatches** the call to the `Mage`'s `attack()` method.
    
4. Is it pointing to a `Warrior`? The JVM dispatches the call to the `Warrior`'s `attack()` method.
    

The main loop doesn't know and doesn't care what kind of character it is. It only knows that it's a `Character` and that all `Character` objects are guaranteed to have an `attack()` method. It trusts the object itself to know how to perform the action correctly.

---
## The "So What?" - The Real Benefits

Now, let's add that `Thief` class.

```java
class Thief extends Character {
    @Override
    public void attack() {
        System.out.println("Thief stabs with a dagger from the shadows!");
    }
}
```

How do we change our main loop to accommodate this new character?

--

**We don't. We don't touch it at all.**

We can simply add a `Thief` to our array, and the loop just works.

```java
Character[] characters = { new Mage(), new Warrior(), new Thief(), new Archer() };

for (Character character : characters) {
    character.attack(); // This loop is unchanged and now works with Thief!
}
```

--

**This is the payoff.** The system is now extensible. We can add 100 new character types without ever modifying the core game logic. This makes our code:

- **Maintainable:** Bugs are less likely because we aren't changing working code.
    
- **Flexible:** The system easily adapts to new requirements.
    
- **Decoupled:** The main loop is no longer tightly coupled to the concrete character classes. It only depends on the `Character` abstraction.
    

---

### More Real-World Examples

- **GUI Programming:** Imagine a `Button`, a `Checkbox`, and a `Slider`. They are all components that can be drawn on the screen. A `render` loop can iterate through a list of `GUIComponent` objects and call `component.draw()`. The button draws itself one way, the slider another, but the render loop doesn't care about the details.
    
- **Payment Processing:** An e-commerce site can process payments. You might have `CreditCardPayment`, `PayPalPayment`, and `CryptoPayment` classes. The shopping cart can have a list of `PaymentMethod` objects and just call `method.process(amount)`.
    
- **File Handling:** A text editor can save files in different formats. You could have `SaveAsDocx`, `SaveAsPdf`, and `SaveAsTxt` classes, all inheriting from a `FileSaver` class. The "Save" menu option just calls `fileSaver.save(document)`.
    

---

## Benefits of Polymorphism

- **Flexibility & Extensibility:** New classes can be added without modifying existing code, as long as they adhere to the common superclass interface.
    
- **Code Reusability:** Write generic code that works with objects of a base type, and it automatically adapts to specific subclass implementations.
    
- **Maintainability:** Easier to manage and update code.
    
- **Clearer Code:** Reduces conditional logic (`if-else` or `switch` statements) because the correct method is invoked automatically.

**Conclusion:** Runtime polymorphism isn't just a pattern; it's a fundamental shift in thinking. 

Instead of a central piece of code asking "What type are you, so I know what to do?", you tell the object "Do the thing," and trust the object itself to know how. 

This delegation of responsibility is the key to building large, complex systems that don't collapse under their own weight.

---

## Introduction to Static Members

- The `static` keyword in Java is used for memory management, primarily.
    
- It signifies that a member (variable or method) belongs to the **class itself**, rather than to any specific instance of the class.
    
- **Static members are shared among all instances of a class.**
    

---

## Static Variables (Class Variables)

- **Declaration:** `static data_type variableName;`
    
- **Belong to the Class:** There is only one copy of a static variable per class, regardless of how many objects are created (or if no objects are created).
    
- **Memory:** Stored in the class area of memory, not in the heap with object instances.
    
- **Access:** Can be accessed directly using the class name (e.g., `ClassName.variableName`) or indirectly through an object reference (though this is discouraged for clarity).
    

---

## Static Variables Example

```java
class Student {
    String name;
    int rollNo;
    static String college = "XYZ University"; // Static variable

    Student(String n, int r) {
        this.name = n;
        this.rollNo = r;
    }

    void display() {
        System.out.println(name + " " + rollNo + " " + college);
    }
}

public class StaticVarDemo {
    public static void main(String[] args) {
        Student s1 = new Student("Alice", 101);
        Student s2 = new Student("Bob", 102);

        s1.display(); // Output: Alice 101 XYZ University
        s2.display(); // Output: Bob 102 XYZ University

        Student.college = "ABC University"; // Change static variable
        s1.display(); // Output: Alice 101 ABC University
    }
}
```

**Observation:** Changing `college` via `Student.college` affects all students.

---

## Static Methods (Class Methods)

- **Declaration:** `static return_type methodName(parameters) { ... }`
    
- **Belong to the Class:** Can be called directly using the class name (e.g., `ClassName.methodName()`) without creating an object.
    
- **Restrictions:**
    
    - A `static` method can **only** access `static` variables and call other `static` methods of the same class.
        
    - It **cannot** use `this` or `super` keywords.
        
    - It **cannot** directly access instance variables or call instance methods because it doesn't operate on a specific object.
        

---

## Static Methods Example

```java
class MathUtils {
    static final double PI = 3.14159; // A static final variable (constant)

    static int add(int a, int b) { // Static method
        return a + b;
    }

    static double getCircleArea(double radius) { // Static method
        return PI * radius * radius;
    }

    // This method would cause a compile-time error if uncommented
    // String instanceData = "Some data";
    // static void problematicMethod() {
    //     System.out.println(instanceData); // ERROR: Cannot access instance var
    // }
}

public class StaticMethodDemo {
    public static void main(String[] args) {
        int sum = MathUtils.add(5, 3);
        System.out.println("Sum: " + sum); // Output: Sum: 8

        double area = MathUtils.getCircleArea(10);
        System.out.println("Area: " + area); // Output: Area: 314.159
    }
}
```

**Usage:** Notice how methods are called directly on the class `MathUtils`.

---

## When to Use Static Members

- **Static Variables:**
    
    - When a property is common to _all_ objects of a class (e.g., a company name, a counter for instances).
        
    - To define constants (`static final`).
        
- **Static Methods:**
    
    - Utility methods that perform operations without needing object-specific data (e.g., mathematical functions, helper methods).
        
    - Factory methods (methods that create and return objects).
        
    - Methods that only operate on static variables.
        
- **Main Method:** The `main` method in Java is `static` so that the JVM can call it to start the program without needing to create an object of the class.
    

---

## Key Differences: Instance vs. Static

|Feature|Instance Members (Non-Static)|Static Members (Class)|
|---|---|---|
|**Belongs To**|An object instance|The class itself|
|**Memory**|Separate copy for each object (Heap)|One copy for the entire class (Class Area)|
|**Access**|Requires an object to call/access|Can be called/accessed directly using class name|
|**`this`/`super`**|Can use `this` and `super`|Cannot use `this` or `super`|
|**Access to Other Members**|Can access both instance & static members|Can _only_ access static members|
|**Polymorphism**|Applicable (method overriding)|Not applicable (method hiding instead)|

---

## Summary

- **Polymorphism** allows flexibility:
    
    - **Method Overloading** (Compile-time) - Same method name, different parameters.
        
    - **Method Overriding** (Runtime) - Subclass redefines superclass method.
        
- **Static Members** belong to the class, not an object:
    
    - **Static Variables** are shared across all instances.
        
    - **Static Methods** can only access other static members and are called on the class itself.
        
