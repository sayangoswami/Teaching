<!--
author:   Sayan Goswami
email:    sgoswami@smcm.edu
version:  0.0.1
language: en
narrator: US English Female
comment:  Processing tutorial part 2. This is used for Engaled learning in COSC120
link:     https://cdn.jsdelivr.net/chartist.js/latest/chartist.min.css
script:   https://cdn.jsdelivr.net/chartist.js/latest/chartist.min.js
import: https://raw.githubusercontent.com/liaTemplates/processingjs/master/README.md
-->

# Creative Coding Tutorial 2 - Living Characters

---

### The Problem with Many Variables

So far, you can draw shapes. But what if you wanted to create two or three characters that move independently? You could create separate variables for each one: `float char1X, char1Y, char1SpeedX, ...` ... `float char2X, char2Y, char2SpeedX, ...` ... and so on.

This gets messy very quickly. Imagine trying to add a third character! There's a much cleaner way. We can create a **blueprint** for a single character and then create unique copies from it. In Java, this blueprint is a **class**.

---

### Designing Your First Class

A **class** is a template for creating **objects**. Think of it as a character design sheet. The class is the sheet, and each character you create from it is an **object**.

Let's design a class for a simple `Bouncer`. What information (properties) does a `Bouncer` need to know about itself?

- Its x and y position (`float x, y;`)
    
- Its size (`float size;`)
    
- Its speed (`float xSpeed, ySpeed;`)
    
- Its color (`color c;`)
    

```java
class Bouncer {
  // Properties (instance variables)
  float x, y;
  float size;
  float xSpeed, ySpeed;
  color c;
}
```
@Processing.eval


---

### The Constructor with Parameters

The **constructor** is a special method that runs when you create a new object. It's used to set up the initial properties. We can make our constructor more powerful by giving it **parameters**, allowing us to create unique objects from the start.

This constructor will accept a starting position, size, and color for each new `Bouncer`.

```java
class Bouncer {
  // ... copy the properties from before

  // Constructor with parameters
  Bouncer(float startX, float startY, float s, color col) {
    x = startX;
    y = startY;
    size = s;
    c = col; // Assign the incoming color
    
    // Give it a random initial speed
    xSpeed = random(-3, 3);
    ySpeed = random(-3, 3);
  }
}
```
@Processing.eval


---

### Adding Behavior with Methods

Objects don't just hold data; they can also _do_ things. We define an object's behavior using **methods**. Our `Bouncer` needs to do three things:

1. **Move**: Update its position.
    
2. **Bounce**: Check if it has hit an edge and reverse its direction.
    
3. **Display**: Draw itself on the screen.
    

```java
class Bouncer {
  // ... copy the properties and constructor from before

  void move() {
    x += xSpeed;
    y += ySpeed;
  }
  
  void bounce() {
    if (x < size/2 || x > width - size/2) {
      xSpeed *= -1; // Reverse horizontal speed
    }
    if (y < size/2 || y > height - size/2) {
      ySpeed *= -1; // Reverse vertical speed
    }
  }

  void display() {
    noStroke();
    fill(c);
    ellipse(x, y, size, size);
  }
}
```
@Processing.eval


---

### Creating Your First Object

Now that we have our `Bouncer` blueprint, let's create one.

First, **declare a variable** of type `Bouncer`. Then, in `setup()`, **instantiate** it using the `new` keyword and pass in the arguments for the constructor.

```java
// ... Copy the Bouncer class from before

Bouncer bouncer1; // Declare a variable

void setup() {
  size(600, 400);
  // Create a new Bouncer object with specific starting values
  bouncer1 = new Bouncer(100, 200, 50, color(255, 0, 0)); // A big red bouncer
}

void draw() {
  background(10, 10, 40); // Dark blue background
}
```
@Processing.eval


Run this using the `</>` button above. You won't see anything yet (apart from a blank canvas), but your first unique object has been created!

---

### Bringing the Object to Life

To make our bouncer appear and move, we need to call its methods inside the `draw()` loop. We use dot notation (`object.method()`) to do this.

```java
// ... copy the Bouncer class definition, bouncer1 object, 
// ... and setup method from before

void draw() {
  background(10, 10, 40);
  bouncer1.move();    // Call its move method
  bouncer1.bounce();  // Call its bounce method
  bouncer1.display(); // Call its display method
}
```
@Processing.eval


Run this. You should now see a single red circle moving and bouncing off the walls! You can run it multiple times and the speed of the ball will likely change each time.

---

### The Power of Reusability

Hereâ€™s where classes really shine. We can reuse our `Bouncer` class to create a second, completely independent character with just two more lines of code.

Let's declare another `Bouncer` variable and instantiate it in `setup()` with different arguments.

```java
// ... Copy the Bouncer class definition from before

Bouncer bouncer1;
Bouncer bouncer2; // Declare a second Bouncer

void setup() {
  size(600, 400);
  // Create the first Bouncer
  bouncer1 = new Bouncer(100, 200, 50, color(255, 0, 0)); // Big and red
  // Create a second, different Bouncer
  bouncer2 = new Bouncer(width - 100, 200, 30, color(0, 150, 255)); // Small and blue
}
```
@Processing.eval

Again, when you run it, it wont show anything, but behind the scenes, you have created two Bouncer objects.

---

### Animating Multiple Objects

To get the second bouncer on screen, we just need to call its methods in `draw()`, right alongside the first one. Each object manages its own data, so they won't interfere with each other.

```java
// ... Copy the code from before

void draw() {
  background(10, 10, 40);
  
  // Update and display the first bouncer
  bouncer1.move();
  bouncer1.bounce();
  bouncer1.display();
  
  // Update and display the second bouncer
  bouncer2.move();
  bouncer2.bounce();
  bouncer2.display();
}
```
@Processing.eval


Now you have two distinct objects, created from the same class, behaving independently! This is the core of object-oriented programming.

---

### Adding Interaction

Let's make our objects react to the mouse. We can add a new method to the `Bouncer` class that checks the distance between itself and the mouse cursor.

The built-in `dist(x1, y1, x2, y2)` function is perfect for this.

```java
// ... copy the Bouncer class definition and objects
// ... and setup method from before
// ... Add the following method inside your Bouncer class
void interact() {
  // Calculate distance between the bouncer's center and the mouse
  float d = dist(x, y, mouseX, mouseY);
  
  // If the mouse is close to this bouncer, make it transparent
  if (d < size/2) {
    // We can directly change the color property!
    c = color(red(c), green(c), blue(c), 100); // 100 alpha = transparent
  } else {
    c = color(red(c), green(c), blue(c), 255); // 255 alpha = opaque
  }
}
```
@Processing.eval


---

### Putting it All Together

Finally, call this new `interact()` method for each of your objects inside `draw()`. Notice how each bouncer reacts only when the mouse is over _it_. Each object runs the same code, but on its own unique data.

```java
// ... copy the Bouncer class definition and objects
// ... and setup method from before

void draw() {
  background(10, 10, 40);
  
  bouncer1.interact(); // Check for interaction
  bouncer1.move();
  bouncer1.bounce();
  bouncer1.display();
  
  bouncer2.interact(); // Check for interaction
  bouncer2.move();
  bouncer2.bounce();
  bouncer2.display();
}
```
@Processing.eval


Run the sketch and move your mouse over the bouncers. You've just created a multi-object, interactive program! ðŸ¥³

---

## Programming Assignment: My First Characters

Your assignment is to use classes to create two distinct characters that are aware of each other and the mouse.

### Requirements:

1. **Create a `Character` Class:**

   - It must have properties for `x`, `y`, `size`, and `color`.
   - The **constructor** must accept parameters to set these initial values.
   - It must have a `display()` method that draws the character. Be creative! Use multiple shapes (`rect`, `ellipse`, `triangle`) to make something more interesting than a circle.      
   - It must have a `follow()` method that takes another `Character` object as a parameter (e.g., `void follow(Character other)`). This method should make the character slowly move towards the `other` character's position.

2. **Main Sketch:**

    - Create **two** `Character` objects. Instantiate them with different sizes and colors in `setup()`. Let's call them `leader` and `follower`.
        
    - The `leader` character's position should be controlled directly by the mouse (`leader.x = mouseX; leader.y = mouseY;`).
        
    - The `follower` character should use its `follow()` method to chase the `leader` (`follower.follow(leader);`), but at a limited speed.

3. **Interaction and Conditionals:**

    - Calculate the distance between the `leader` and the `follower` in the main `draw()` loop.
        
    - If they touch each other, they should both change color to something new. When they are far apart again, they should return to their original colors.
        

---

### Grading Rubric (100 points)

| Category                             | Excellent (Full Points)                                                                                                                                     | Sufficient (Half Points)                                                                                              | Needs Improvement (0 Points)                                           | Points    |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- | --------- |
| **`Character` Class (40 pts)**       | The class is well-defined with a parameterized constructor and all required methods. The `follow()` method correctly makes one object move towards another. | The class is mostly complete, but the constructor may be missing parameters, or the `follow()` method has minor bugs. | The class is missing, incomplete, or has major functional errors.      | **/ 40**  |
| **Main Sketch Logic (30 pts)**       | Two distinct `Character` objects are created. One is correctly tied to the mouse, and the other correctly calls its `follow()` method.                      | Two objects are created, but their roles as leader/follower are implemented incorrectly or are buggy.                 | The objects are not created correctly, or the main sketch logic fails. | **/ 30**  |
| **Conditional Interaction (20 pts)** | The program correctly calculates the distance between the two characters and makes them both change color _only_ when they are touching.                    | A distance check is attempted, but the logic is flawed (e.g., colors change permanently or at the wrong distance).    | There is no interaction between the characters.                        | **/ 20**  |
| **Creativity & Code Style (10 pts)** | The character design is creative (uses multiple shapes). The code is well-commented, clean, and easy to read.                                               | The character is a basic shape. The code is functional but lacks comments or is poorly formatted.                     | The sketch is visually unappealing, and the code is difficult to read. | **/ 10**  |
| **Total**                            |                                                                                                                                                             |                                                                                                                       |                                                                        | **/ 100** |

---

### Space for your code (Write here and submit on Blackboard)

```java
// create a Character class ...




// Create 2 character objects ...


// Setup method ...


// Draw method ...


```
@Processing.eval