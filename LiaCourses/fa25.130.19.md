<!--
author:   Sayan Goswami
email:	sgoswami@smcm.edu
version:  0.1.0
language: en
narrator: US English Female

comment:  Java generics

import: https://raw.githubusercontent.com/liaScript/mermaid_template/master/README.md

link: https://fonts.googleapis.com/css2?family=Fira+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap

link: https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Fira+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap

link: https://cdn.jsdelivr.net/gh/sayangoswami/Teaching@main/LiaCourses/theme.css

import: https://raw.githubusercontent.com/LiaScript/CodeRunner/master/README.md

-->

# Java Generics


## The "Old Way" (Pre-Java 5)

Before Generics, collections (like `ArrayList`) held `Object`. This meant they could hold _anything_.

```java
// A list that holds Objects
ArrayList list = new ArrayList();

list.add("Hello");
list.add(new Integer(10)); // mixing types?
list.add(new Student("Bob"));
```

This compiles fine! But what happens when we want to get data **out**?

## The Problem: Casting and Crashes

Because the list holds `Object`, we have to **cast** everything back to what we _think_ it is.

```java
ArrayList list = new ArrayList();
list.add("Hello");

// We have to cast (String) because .get() returns Object
String s = (String) list.get(0); 
```

**The Danger Zone:**

```java
list.add(10); // Added an Integer
String s = (String) list.get(1); // CRASH! ClassCastException
```

We added an Integer, but tried to cast it to a String. **The compiler didn't warn us.** The program just crashed while running.

## The Solution: Generics

Generics allow us to specify **exactly** what type of data a class or collection can hold.

We use the diamond syntax: `<Type>`

```java
// Read as: "ArrayList of String"
ArrayList<String> list = new ArrayList<String>();

list.add("Hello"); // OK!
list.add(10);      // COMPILER ERROR!
```

**The Benefit:** The compiler acts as a "bouncer." It stops invalid types _before_ your code ever runs.

## No More Casting

Because the compiler _knows_ the list only contains Strings, we don't need to cast anymore.

```java
// The "Old" Way
String s = (String) list.get(0);

// The Generic Way
String s = list.get(0); 
```

The code is cleaner, safer, and easier to read.

## Defining Your Own Generic Class

You aren't limited to using Java's lists. You can write your own Generic classes!

Imagine a `Box` that can hold an item.

**Non-Generic Version:**

```java
public class Box {
    private Object item;
    public void set(Object item) { this.item = item; }
    public Object get() { return this.item; }
}
```

_(Requires casting to use. Unsafe.)_

## The Generic `Box<T>`

We use a **Type Parameter**, usually named `T` (for Type), as a placeholder.

```java
// T is a placeholder. It will be replaced later!
public class Box<T> {
    
    private T item; // item is of type T

    public void set(T item) {
        this.item = item;
    }

    public T get() {
        return this.item;
    }
}
```

## Using Your Generic Class

When we create an instance of `Box`, we swap `T` for a real type.

```java
// T becomes String
Box<String> textBoxt = new Box<String>();
textBoxt.set("Hello");
String s = textBoxt.get(); // No casting!

// T becomes Integer
Box<Integer> numberBox = new Box<Integer>();
numberBox.set(100);
int i = numberBox.get();
```

One class definition handles infinite data types!

## Common Type Parameters

You will see these letters used as standard placeholders:

- **`T`** - Type (General purpose)
    
- **`E`** - Element (Used in Collections, like `ArrayList<E>`)
    
- **`K`** - Key (Used in Maps)
    
- **`V`** - Value (Used in Maps)
    
- **`N`** - Number
    

You _can_ name them anything (`Box<Thing>`), but single uppercase letters are the convention.

## Multiple Type Parameters

A class can have more than one generic type.
```java
public class Pair<K, V> {
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    // ... getters ...
}
```

**Usage:** `Pair<String, Integer> score = new Pair<>("Alice", 95);`

## The "Gotcha" - Primitives

**Critical Rule:** Generics only work with **Reference Types (Objects)**. They do _not_ work with primitives.

```java
ArrayList<int> list; // ERROR
Box<double> box;     // ERROR
```

You **must** use Wrapper Classes:

```java
ArrayList<Integer> list; // Correct
Box<Double> box;         // Correct
```



## Generics vs. Method Overloading

Imagine we need a utility class to **print the contents of an array**.

We want it to work for:

1. Integer Arrays
2. Double Arrays
3. Character Arrays
4. String Arrays

Let's try to solve this using what we already know: **Method Overloading**.



## Attempt 1: Method Overloading

We write a method for every type we need.

```java
public class Printer {

    // For Integers
    public void printArray(Integer[] input) {
        for (Integer element : input) {
            System.out.print(element + " ");
        }
        System.out.println();
    }

    // For Doubles (Look familiar?)
    public void printArray(Double[] input) {
        for (Double element : input) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    // For Strings (Exact same logic...)
    public void printArray(String[] input) {
        for (String element : input) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
}
```



## The Problem with Overloading

Look at the previous slide. **The logic inside the methods is identical.**

**The Issues:**

1. **Code Duplication:** We violated the "DRY" (Don't Repeat Yourself) principle.
    
2. **Scalability:** What if we want to print a `Student[]` array? We have to write _another_ method.
    
3. **Maintenance:** If we want to change the print format (e.g., add commas), we have to change it in **every single method**.
    

Method Overloading is great when the _logic_ is different. It is terrible when the logic is the same.



## Attempt 2: Generic Methods

Instead of copy-pasting, let's write **one** method that can handle **any** type of object.

We declare a type parameter `<T>` before the return type.


```java
public class Printer {

    // One method to rule them all
    public <T> void printArray(T[] input) {
        
        for (T element : input) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
}
```



## How Generics Solve the Problem

When you call the generic method, Java automatically determines what `T` is.


```java
Printer p = new Printer();

Integer[] intArray = { 1, 2, 3 };
String[] strArray = { "Hello", "World" };

// T becomes Integer
p.printArray(intArray); 

// T becomes String
p.printArray(strArray);
```

We wrote the code **once**, and it works for infinite types.



## Comparison Summary

<!-- data-type="none" data-sortable="false" -->
|Feature|Method Overloading|Generics|
|---|---|---|
|**Code Quantity**|Increases with every new data type.|Stays the same (One method).|
|**Maintenance**|Hard. Must update every copy.|Easy. Update one place.|
|**Type Safety**|Safe (Compiler checks types).|Safe (Compiler checks types).|
|**Best Use Case**|When specific types require **different** actions.|When different types require the **same** action.|



## When should you STILL use Overloading?

Generics are not always the answer. Use **Overloading** if the implementation details need to change based on the type.

**Example:**

- `print(String s)` -> Prints the string as is.
    
- `print(Double d)` -> Formats it to 2 decimal places.
    

Because the _logic_ inside is different, Overloading is the correct choice here.

---

## Programming Worksheet

**Refactoring Challenge: The Swapper**

Below is code using Method Overloading to swap two elements in an array.

Task: Rewrite this class to use a Single Generic Method.

**The Old Code:**


```java
import java.util.Arrays;

class Swapper {
    // Swap Integers
    public static void swap(Integer[] arr, int i, int j) {
        Integer temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Swap Strings
    public static void swap(String[] arr, int i, int j) {
        String temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

public class Main {
	public static void main(String[] args) {
		Integer[] intarr = {1, 2, 3, 4, 5};
		String[] strarr = {"Alice", "Bob", "Charlie", "Dylan", "Ellis"};
		
		Swapper.swap(intarr, 2, 3);
		System.out.println(Arrays.toString(intarr));
		
		Swapper.swap(strarr, 1, 4);
		System.out.println(Arrays.toString(strarr));
	}
}
```
@LIA.java(Main)

**Your Goal:**

1. Delete the two methods.
    
2. Write `public static <T> void swap(T[] arr, int i, int j)`.
    
3. Test it in `main` with both an Integer array and a String array.